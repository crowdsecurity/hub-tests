package main

import (
	"flag"
	"io/ioutil"
	"os"
	"strings"

	"github.com/crowdsecurity/crowdsec/pkg/csconfig"
	"github.com/crowdsecurity/crowdsec/pkg/cwhub"
	"github.com/crowdsecurity/crowdsec/pkg/cwversion"
	"github.com/crowdsecurity/crowdsec/pkg/exprhelpers"
	leaky "github.com/crowdsecurity/crowdsec/pkg/leakybucket"
	"github.com/crowdsecurity/crowdsec/pkg/parser"
	"github.com/crowdsecurity/crowdsec/pkg/types"
	log "github.com/sirupsen/logrus"
	"gopkg.in/tomb.v2"
	"gopkg.in/yaml.v2"
)

var (
	acquisTomb tomb.Tomb

	AllResults    []LineParseResult
	AllExpected   []LineParseResult
	AllPoResults  []LineParsePoResult
	AllPoExpected []LineParsePoResult

	holders []leaky.BucketFactory
	buckets *leaky.Buckets

	outputEventChan chan types.Event
)

type ConfigTest struct {
	//to know which configuration we want to test
	Parse        bool `yaml:"parse"`
	Bucket       bool `yaml:"bucket"`
	Postoverflow bool `yaml:"postoverflow"`
	//parsers files
	logFile         string `yaml:"log_file"`
	ParseResultFile string `yaml:"parser_results"`

	//bucket files
	//Nota: bucketInputFile is generated by parsing
	bucketInputFile  string `yaml:"bucket_input"`
	bucketResultFile string `yaml:"bucket_results"`

	//po files
	//Nota: poResultFile is generated by buckets
	poInputFile  string `yaml:"postoveflow_input"`
	poResultFile string `yaml:"postoverflow_results"`

	//configuration
	acquisitionFile string `yaml:"acquisition_file"`

	IndexFile string `yaml:"index"`
	//configuration list. For now sorting by type is mandatory
	Configurations map[string][]string `yaml:"configurations"`
}

type LineParseResult struct {
	Line          string
	ParserResults map[string]map[string]types.Event
}

type LineParsePoResult struct {
	Overflow      types.RuntimeAlert
	ParserResults map[string]map[string]types.Event
}

type Flags struct {
	ConfigFile    string
	TargetDir     string
	JUnitFilename string
}

func (f *Flags) Parse() {
	flag.StringVar(&f.ConfigFile, "config", "./dev.yaml", "configuration file")
	flag.StringVar(&f.TargetDir, "target", "", "target test dir")
	flag.StringVar(&f.JUnitFilename, "junit", "", "junit file name")

	flag.Parse()
}

func main() {
	var (
		err         error
		cConfig     *csconfig.GlobalConfig
		flags       *Flags
		files       []string
		localConfig ConfigTest
		index       map[string]map[string]cwhub.Item

		report *JUnitTestSuites
	)

	log.SetLevel(log.InfoLevel)
	log.SetOutput(os.Stdout)

	log.Infof("built against %s", cwversion.VersionStr())
	flags = &Flags{}
	flags.Parse()

	if flags.TargetDir == "" {
		log.Fatalf("A target test directory is required (-target)")
	}

	cConfig = csconfig.NewConfig()
	// err = cConfig.LoadConfigurationFile(flags.ConfigFile)
	// if err != nil {
	// 	log.Fatalf("Failed to load configuration : %s", err)
	// }

	//fill localConfig with default
	path := flags.TargetDir + "/config.yaml"
	localConfig = ConfigTest{
		logFile:          "acquis.log",
		ParseResultFile:  "parser_result.json",
		bucketInputFile:  "bucket_input.yaml",
		bucketResultFile: "bucket_result.json",
		poInputFile:      "po_input.yaml",
		poResultFile:     "postoverflow_result.json",
		IndexFile:        ".index.json",
	}
	fcontent, err := ioutil.ReadFile(path)
	if err != nil {
		log.Fatalf("failed to read config file: %s", err)
	}
	err = yaml.Unmarshal(fcontent, &localConfig)
	if err != nil {
		log.Fatalf("failed unmarshaling config: %s", err)
	}

	//Minimal configuration loading
	//TODO move this to a specific function
	cConfig.API = &csconfig.APICfg{}
	cConfig.ConfigPaths = &csconfig.ConfigurationPaths{
		ConfigDir:    "./config",
		DataDir:      "./data",
		HubIndexFile: localConfig.IndexFile,
	}
	cConfig.Crowdsec = &csconfig.CrowdsecServiceCfg{
		AcquisitionFilePath: flags.TargetDir + "/acquis.yaml",
	}

	err = cConfig.LoadConfiguration()
	if err != nil {
		log.Fatalf("Failed to load configuration : %s", err)
	}

	err = exprhelpers.Init()
	if err != nil {
		log.Fatalf("Failed to init expr helpers : %s", err)
	}

	//Load index file
	buf, err := ioutil.ReadFile(localConfig.IndexFile)
	if err != nil {
		log.Fatalf("failed to read index file %s: %s", localConfig.IndexFile, err)
	}

	if index, err = cwhub.LoadPkgIndex(buf); err != nil {
		log.Fatalf("failed to read index file: %s", err)
	}

	csParsers := newParsers(index, localConfig)

	if csParsers, err = parser.LoadParsers(cConfig, csParsers); err != nil {
		log.Fatalf("Failed to load parsers: %s", err)
	}

	files = newBuckets(index, localConfig)
	log.Printf("files: %+v", files)
	log.Infof("Loading %d scenario files", len(files))

	buckets = leaky.NewBuckets()
	holders, outputEventChan, err = leaky.LoadBuckets(cConfig.Crowdsec, files)

	if flags.JUnitFilename != "" {
		if report, err = LoadJunitReport(flags.JUnitFilename); err != nil {
			log.Fatalf("Error loading JUnit file: %s", flags.JUnitFilename)
		}
	}

	if _, ok := localConfig.Configurations["parsers"]; ok {
		err := testParser(flags.TargetDir, csParsers, cConfig, localConfig)
		if err != nil {
			log.Errorf("Error: %s", err)
		}
		if flags.JUnitFilename != "" {
			report.AddSingleResult(cwhub.PARSERS, err, strings.Join(localConfig.Configurations[cwhub.PARSERS], ", "))
		}
	}

	if _, ok := localConfig.Configurations["scenarios"]; ok {
		err = testBuckets(flags.TargetDir, cConfig, localConfig)
		if err != nil {
			log.Errorf("Error: %s", err)
		}
		if flags.JUnitFilename != "" {
			report.AddSingleResult(cwhub.SCENARIOS, err, strings.Join(localConfig.Configurations[cwhub.SCENARIOS], ", "))
		}
	}

	if _, ok := localConfig.Configurations["postoverflows"]; ok {
		err = testPwfl(flags.TargetDir, csParsers, localConfig)
		if err != nil {
			log.Errorf("Error: %s", err)
		}
		if flags.JUnitFilename != "" {
			report.AddSingleResult(cwhub.PARSERS_OVFLW, err, strings.Join(localConfig.Configurations[cwhub.PARSERS_OVFLW], ", "))
		}
	}

	if flags.JUnitFilename != "" {
		report.StoreJunitReport(flags.JUnitFilename)
	}

	log.Infof("tests are finished.")

}
